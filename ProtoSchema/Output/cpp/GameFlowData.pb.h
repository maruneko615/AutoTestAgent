// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameFlowData.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GameFlowData_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GameFlowData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameFlowData_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GameFlowData_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GameFlowData_2eproto;
namespace sr4 {
class GameFlowData;
struct GameFlowDataDefaultTypeInternal;
extern GameFlowDataDefaultTypeInternal _GameFlowData_default_instance_;
class GameRaceData;
struct GameRaceDataDefaultTypeInternal;
extern GameRaceDataDefaultTypeInternal _GameRaceData_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace sr4
PROTOBUF_NAMESPACE_OPEN
template<> ::sr4::GameFlowData* Arena::CreateMaybeMessage<::sr4::GameFlowData>(Arena*);
template<> ::sr4::GameRaceData* Arena::CreateMaybeMessage<::sr4::GameRaceData>(Arena*);
template<> ::sr4::Vector3* Arena::CreateMaybeMessage<::sr4::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sr4 {

enum EGameFlowState : int {
  GAME_FLOW_COPYRIGHT = 0,
  GAME_FLOW_WARNING = 1,
  GAME_FLOW_LOGO = 2,
  GAME_FLOW_PV = 3,
  GAME_FLOW_COIN_PAGE = 4,
  GAME_FLOW_SELECT_BIKE = 5,
  GAME_FLOW_SELECT_SCENE = 6,
  GAME_FLOW_RACE = 7,
  GAME_FLOW_RACE_END = 8,
  GAME_FLOW_GAME_OVER = 9,
  GAME_FLOW_RANKING = 10,
  GAME_FLOW_PROMOTION = 11,
  GAME_FLOW_ACCOUNT_ENTRY = 12,
  GAME_FLOW_PHOTO_AUTH = 13,
  GAME_FLOW_SELECT_MODE = 14,
  GAME_FLOW_PAY_FOR_LEVEL = 15,
  GAME_FLOW_RIDE_SHOW = 16,
  GAME_FLOW_LOAD_FLOW = 17,
  GAME_FLOW_LOAD_GAME = 18,
  GAME_FLOW_CUTSCENE = 19,
  GAME_FLOW_MAP_BEAT_SHOW = 20,
  GAME_FLOW_SIGN_NAME = 21,
  GAME_FLOW_CONTINUE = 22,
  GAME_FLOW_HARDWARE_DETECT = 23,
  GAME_FLOW_LOAD_CONTINUE = 24,
  GAME_FLOW_LOAD_STANDBY = 25,
  GAME_FLOW_OPERATOR_SETTING = 26,
  GAME_FLOW_AIRSPRING_ADJUST = 27,
  GAME_FLOW_PLAYER_REGISTRATION = 28,
  GAME_FLOW_WARNING_FOR_SELECTION = 29,
  GAME_FLOW_BATTLE_MAP = 30,
  GAME_FLOW_M23_READ = 31,
  GAME_FLOW_RACE_FINISH_SHOW = 32,
  GAME_FLOW_PLAYER_INFO = 33,
  GAME_FLOW_LOCAL_BEAT_SHOW = 34,
  GAME_FLOW_AGENT_LOGO = 35,
  GAME_FLOW_UE_LOGO = 36,
  GAME_FLOW_CRIWARE_LOGO = 37,
  GAME_FLOW_STATIC_COIN_PAGE = 38,
  GAME_FLOW_LOAD_RACE_RESULT = 39,
  GAME_FLOW_MAX = 40,
  EGameFlowState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EGameFlowState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EGameFlowState_IsValid(int value);
constexpr EGameFlowState EGameFlowState_MIN = GAME_FLOW_COPYRIGHT;
constexpr EGameFlowState EGameFlowState_MAX = GAME_FLOW_MAX;
constexpr int EGameFlowState_ARRAYSIZE = EGameFlowState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameFlowState_descriptor();
template<typename T>
inline const std::string& EGameFlowState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameFlowState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameFlowState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameFlowState_descriptor(), enum_t_value);
}
inline bool EGameFlowState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGameFlowState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameFlowState>(
    EGameFlowState_descriptor(), name, value);
}
enum EGameMode : int {
  GAME_MODE_LOCAL_VERSUS = 0,
  GAME_MODE_GLOBAL_VERSUS = 1,
  EGameMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EGameMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EGameMode_IsValid(int value);
constexpr EGameMode EGameMode_MIN = GAME_MODE_LOCAL_VERSUS;
constexpr EGameMode EGameMode_MAX = GAME_MODE_GLOBAL_VERSUS;
constexpr int EGameMode_ARRAYSIZE = EGameMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameMode_descriptor();
template<typename T>
inline const std::string& EGameMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameMode_descriptor(), enum_t_value);
}
inline bool EGameMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGameMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameMode>(
    EGameMode_descriptor(), name, value);
}
enum ETrack : int {
  TRACK_NONE = 0,
  TRACK_LAS_VEGAS = 1,
  TRACK_BEIJING = 2,
  TRACK_SEOUL = 3,
  TRACK_SHANGHAI = 4,
  TRACK_THAILAND = 5,
  TRACK_CHONGQING = 6,
  TRACK_PHYSICS_TEST = 7,
  TRACK_PHYSICS_TEST_2 = 8,
  TRACK_DELIA_HUANG_TEST = 9,
  TRACK_SHOU_WEIKU_TEST = 10,
  TRACK_MAX = 11,
  ETrack_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ETrack_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ETrack_IsValid(int value);
constexpr ETrack ETrack_MIN = TRACK_NONE;
constexpr ETrack ETrack_MAX = TRACK_MAX;
constexpr int ETrack_ARRAYSIZE = ETrack_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETrack_descriptor();
template<typename T>
inline const std::string& ETrack_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETrack>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETrack_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETrack_descriptor(), enum_t_value);
}
inline bool ETrack_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETrack* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETrack>(
    ETrack_descriptor(), name, value);
}
enum ERouteDirection : int {
  ROUTE_DIRECTION_CLOCKWISE = 0,
  ROUTE_DIRECTION_COUNTER_CLOCKWISE = 1,
  ROUTE_DIRECTION_MAX = 2,
  ERouteDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ERouteDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ERouteDirection_IsValid(int value);
constexpr ERouteDirection ERouteDirection_MIN = ROUTE_DIRECTION_CLOCKWISE;
constexpr ERouteDirection ERouteDirection_MAX = ROUTE_DIRECTION_MAX;
constexpr int ERouteDirection_ARRAYSIZE = ERouteDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERouteDirection_descriptor();
template<typename T>
inline const std::string& ERouteDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERouteDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERouteDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERouteDirection_descriptor(), enum_t_value);
}
inline bool ERouteDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERouteDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERouteDirection>(
    ERouteDirection_descriptor(), name, value);
}
enum EVehicleType : int {
  VEHICLE_MSQ = 0,
  VEHICLE_MAA = 1,
  VEHICLE_MUR = 2,
  VEHICLE_MHA = 3,
  VEHICLE_MRA = 4,
  VEHICLE_MAD = 5,
  VEHICLE_MCE = 6,
  VEHICLE_MQB = 7,
  VEHICLE_MAX = 8,
  EVehicleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EVehicleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EVehicleType_IsValid(int value);
constexpr EVehicleType EVehicleType_MIN = VEHICLE_MSQ;
constexpr EVehicleType EVehicleType_MAX = VEHICLE_MAX;
constexpr int EVehicleType_ARRAYSIZE = EVehicleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EVehicleType_descriptor();
template<typename T>
inline const std::string& EVehicleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EVehicleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EVehicleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EVehicleType_descriptor(), enum_t_value);
}
inline bool EVehicleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EVehicleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EVehicleType>(
    EVehicleType_descriptor(), name, value);
}
enum EPhotoType : int {
  PHOTO_HELMET = 0,
  PHOTO_VEIL = 1,
  PHOTO_DIVING_GOGGLES = 2,
  PHOTO_FACE_MASK = 3,
  PHOTO_COMIC_MASK = 4,
  PHOTO_SEA_ELF = 5,
  PHOTO_KNIGHT_HELMET = 6,
  PHOTO_EMOJI_MASK = 7,
  PHOTO_DOLL_HEADGEAR = 8,
  PHOTO_SICHUAN_OPERA_MAKEUP = 9,
  PHOTO_ORIGAMI = 10,
  PHOTO_LION_DANCE = 11,
  EPhotoType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EPhotoType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EPhotoType_IsValid(int value);
constexpr EPhotoType EPhotoType_MIN = PHOTO_HELMET;
constexpr EPhotoType EPhotoType_MAX = PHOTO_LION_DANCE;
constexpr int EPhotoType_ARRAYSIZE = EPhotoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPhotoType_descriptor();
template<typename T>
inline const std::string& EPhotoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPhotoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPhotoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPhotoType_descriptor(), enum_t_value);
}
inline bool EPhotoType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPhotoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPhotoType>(
    EPhotoType_descriptor(), name, value);
}
// ===================================================================

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sr4.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sr4.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:sr4.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GameFlowData_2eproto;
};
// -------------------------------------------------------------------

class GameRaceData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sr4.GameRaceData) */ {
 public:
  inline GameRaceData() : GameRaceData(nullptr) {}
  ~GameRaceData() override;
  explicit PROTOBUF_CONSTEXPR GameRaceData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameRaceData(const GameRaceData& from);
  GameRaceData(GameRaceData&& from) noexcept
    : GameRaceData() {
    *this = ::std::move(from);
  }

  inline GameRaceData& operator=(const GameRaceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameRaceData& operator=(GameRaceData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameRaceData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameRaceData* internal_default_instance() {
    return reinterpret_cast<const GameRaceData*>(
               &_GameRaceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameRaceData& a, GameRaceData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameRaceData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameRaceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameRaceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameRaceData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameRaceData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameRaceData& from) {
    GameRaceData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRaceData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sr4.GameRaceData";
  }
  protected:
  explicit GameRaceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPosFieldNumber = 1,
    kTargetPositionFieldNumber = 2,
    kNormalFieldNumber = 3,
  };
  // .sr4.Vector3 current_pos = 1;
  bool has_current_pos() const;
  private:
  bool _internal_has_current_pos() const;
  public:
  void clear_current_pos();
  const ::sr4::Vector3& current_pos() const;
  PROTOBUF_NODISCARD ::sr4::Vector3* release_current_pos();
  ::sr4::Vector3* mutable_current_pos();
  void set_allocated_current_pos(::sr4::Vector3* current_pos);
  private:
  const ::sr4::Vector3& _internal_current_pos() const;
  ::sr4::Vector3* _internal_mutable_current_pos();
  public:
  void unsafe_arena_set_allocated_current_pos(
      ::sr4::Vector3* current_pos);
  ::sr4::Vector3* unsafe_arena_release_current_pos();

  // .sr4.Vector3 target_position = 2;
  bool has_target_position() const;
  private:
  bool _internal_has_target_position() const;
  public:
  void clear_target_position();
  const ::sr4::Vector3& target_position() const;
  PROTOBUF_NODISCARD ::sr4::Vector3* release_target_position();
  ::sr4::Vector3* mutable_target_position();
  void set_allocated_target_position(::sr4::Vector3* target_position);
  private:
  const ::sr4::Vector3& _internal_target_position() const;
  ::sr4::Vector3* _internal_mutable_target_position();
  public:
  void unsafe_arena_set_allocated_target_position(
      ::sr4::Vector3* target_position);
  ::sr4::Vector3* unsafe_arena_release_target_position();

  // .sr4.Vector3 normal = 3;
  bool has_normal() const;
  private:
  bool _internal_has_normal() const;
  public:
  void clear_normal();
  const ::sr4::Vector3& normal() const;
  PROTOBUF_NODISCARD ::sr4::Vector3* release_normal();
  ::sr4::Vector3* mutable_normal();
  void set_allocated_normal(::sr4::Vector3* normal);
  private:
  const ::sr4::Vector3& _internal_normal() const;
  ::sr4::Vector3* _internal_mutable_normal();
  public:
  void unsafe_arena_set_allocated_normal(
      ::sr4::Vector3* normal);
  ::sr4::Vector3* unsafe_arena_release_normal();

  // @@protoc_insertion_point(class_scope:sr4.GameRaceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sr4::Vector3* current_pos_;
    ::sr4::Vector3* target_position_;
    ::sr4::Vector3* normal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GameFlowData_2eproto;
};
// -------------------------------------------------------------------

class GameFlowData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sr4.GameFlowData) */ {
 public:
  inline GameFlowData() : GameFlowData(nullptr) {}
  ~GameFlowData() override;
  explicit PROTOBUF_CONSTEXPR GameFlowData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameFlowData(const GameFlowData& from);
  GameFlowData(GameFlowData&& from) noexcept
    : GameFlowData() {
    *this = ::std::move(from);
  }

  inline GameFlowData& operator=(const GameFlowData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameFlowData& operator=(GameFlowData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameFlowData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameFlowData* internal_default_instance() {
    return reinterpret_cast<const GameFlowData*>(
               &_GameFlowData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GameFlowData& a, GameFlowData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameFlowData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameFlowData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameFlowData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameFlowData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameFlowData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameFlowData& from) {
    GameFlowData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameFlowData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sr4.GameFlowData";
  }
  protected:
  explicit GameFlowData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaceDataFieldNumber = 7,
    kCurrentFlowStateFieldNumber = 1,
    kSelectedModeFieldNumber = 2,
    kSelectedTrackFieldNumber = 3,
    kSelectedRouteDirectionFieldNumber = 4,
    kSelectedVehicleFieldNumber = 5,
    kSelectedPhotoFieldNumber = 6,
  };
  // .sr4.GameRaceData race_data = 7;
  bool has_race_data() const;
  private:
  bool _internal_has_race_data() const;
  public:
  void clear_race_data();
  const ::sr4::GameRaceData& race_data() const;
  PROTOBUF_NODISCARD ::sr4::GameRaceData* release_race_data();
  ::sr4::GameRaceData* mutable_race_data();
  void set_allocated_race_data(::sr4::GameRaceData* race_data);
  private:
  const ::sr4::GameRaceData& _internal_race_data() const;
  ::sr4::GameRaceData* _internal_mutable_race_data();
  public:
  void unsafe_arena_set_allocated_race_data(
      ::sr4::GameRaceData* race_data);
  ::sr4::GameRaceData* unsafe_arena_release_race_data();

  // .sr4.EGameFlowState current_flow_state = 1;
  void clear_current_flow_state();
  ::sr4::EGameFlowState current_flow_state() const;
  void set_current_flow_state(::sr4::EGameFlowState value);
  private:
  ::sr4::EGameFlowState _internal_current_flow_state() const;
  void _internal_set_current_flow_state(::sr4::EGameFlowState value);
  public:

  // .sr4.EGameMode selected_mode = 2;
  void clear_selected_mode();
  ::sr4::EGameMode selected_mode() const;
  void set_selected_mode(::sr4::EGameMode value);
  private:
  ::sr4::EGameMode _internal_selected_mode() const;
  void _internal_set_selected_mode(::sr4::EGameMode value);
  public:

  // .sr4.ETrack selected_track = 3;
  void clear_selected_track();
  ::sr4::ETrack selected_track() const;
  void set_selected_track(::sr4::ETrack value);
  private:
  ::sr4::ETrack _internal_selected_track() const;
  void _internal_set_selected_track(::sr4::ETrack value);
  public:

  // .sr4.ERouteDirection selected_route_direction = 4;
  void clear_selected_route_direction();
  ::sr4::ERouteDirection selected_route_direction() const;
  void set_selected_route_direction(::sr4::ERouteDirection value);
  private:
  ::sr4::ERouteDirection _internal_selected_route_direction() const;
  void _internal_set_selected_route_direction(::sr4::ERouteDirection value);
  public:

  // .sr4.EVehicleType selected_vehicle = 5;
  void clear_selected_vehicle();
  ::sr4::EVehicleType selected_vehicle() const;
  void set_selected_vehicle(::sr4::EVehicleType value);
  private:
  ::sr4::EVehicleType _internal_selected_vehicle() const;
  void _internal_set_selected_vehicle(::sr4::EVehicleType value);
  public:

  // .sr4.EPhotoType selected_photo = 6;
  void clear_selected_photo();
  ::sr4::EPhotoType selected_photo() const;
  void set_selected_photo(::sr4::EPhotoType value);
  private:
  ::sr4::EPhotoType _internal_selected_photo() const;
  void _internal_set_selected_photo(::sr4::EPhotoType value);
  public:

  // @@protoc_insertion_point(class_scope:sr4.GameFlowData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sr4::GameRaceData* race_data_;
    int current_flow_state_;
    int selected_mode_;
    int selected_track_;
    int selected_route_direction_;
    int selected_vehicle_;
    int selected_photo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GameFlowData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:sr4.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sr4.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:sr4.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sr4.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:sr4.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sr4.Vector3.z)
}

// -------------------------------------------------------------------

// GameRaceData

// .sr4.Vector3 current_pos = 1;
inline bool GameRaceData::_internal_has_current_pos() const {
  return this != internal_default_instance() && _impl_.current_pos_ != nullptr;
}
inline bool GameRaceData::has_current_pos() const {
  return _internal_has_current_pos();
}
inline void GameRaceData::clear_current_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.current_pos_ != nullptr) {
    delete _impl_.current_pos_;
  }
  _impl_.current_pos_ = nullptr;
}
inline const ::sr4::Vector3& GameRaceData::_internal_current_pos() const {
  const ::sr4::Vector3* p = _impl_.current_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::sr4::Vector3&>(
      ::sr4::_Vector3_default_instance_);
}
inline const ::sr4::Vector3& GameRaceData::current_pos() const {
  // @@protoc_insertion_point(field_get:sr4.GameRaceData.current_pos)
  return _internal_current_pos();
}
inline void GameRaceData::unsafe_arena_set_allocated_current_pos(
    ::sr4::Vector3* current_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_pos_);
  }
  _impl_.current_pos_ = current_pos;
  if (current_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sr4.GameRaceData.current_pos)
}
inline ::sr4::Vector3* GameRaceData::release_current_pos() {
  
  ::sr4::Vector3* temp = _impl_.current_pos_;
  _impl_.current_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sr4::Vector3* GameRaceData::unsafe_arena_release_current_pos() {
  // @@protoc_insertion_point(field_release:sr4.GameRaceData.current_pos)
  
  ::sr4::Vector3* temp = _impl_.current_pos_;
  _impl_.current_pos_ = nullptr;
  return temp;
}
inline ::sr4::Vector3* GameRaceData::_internal_mutable_current_pos() {
  
  if (_impl_.current_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::sr4::Vector3>(GetArenaForAllocation());
    _impl_.current_pos_ = p;
  }
  return _impl_.current_pos_;
}
inline ::sr4::Vector3* GameRaceData::mutable_current_pos() {
  ::sr4::Vector3* _msg = _internal_mutable_current_pos();
  // @@protoc_insertion_point(field_mutable:sr4.GameRaceData.current_pos)
  return _msg;
}
inline void GameRaceData::set_allocated_current_pos(::sr4::Vector3* current_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.current_pos_;
  }
  if (current_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(current_pos);
    if (message_arena != submessage_arena) {
      current_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.current_pos_ = current_pos;
  // @@protoc_insertion_point(field_set_allocated:sr4.GameRaceData.current_pos)
}

// .sr4.Vector3 target_position = 2;
inline bool GameRaceData::_internal_has_target_position() const {
  return this != internal_default_instance() && _impl_.target_position_ != nullptr;
}
inline bool GameRaceData::has_target_position() const {
  return _internal_has_target_position();
}
inline void GameRaceData::clear_target_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_position_ != nullptr) {
    delete _impl_.target_position_;
  }
  _impl_.target_position_ = nullptr;
}
inline const ::sr4::Vector3& GameRaceData::_internal_target_position() const {
  const ::sr4::Vector3* p = _impl_.target_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::sr4::Vector3&>(
      ::sr4::_Vector3_default_instance_);
}
inline const ::sr4::Vector3& GameRaceData::target_position() const {
  // @@protoc_insertion_point(field_get:sr4.GameRaceData.target_position)
  return _internal_target_position();
}
inline void GameRaceData::unsafe_arena_set_allocated_target_position(
    ::sr4::Vector3* target_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_position_);
  }
  _impl_.target_position_ = target_position;
  if (target_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sr4.GameRaceData.target_position)
}
inline ::sr4::Vector3* GameRaceData::release_target_position() {
  
  ::sr4::Vector3* temp = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sr4::Vector3* GameRaceData::unsafe_arena_release_target_position() {
  // @@protoc_insertion_point(field_release:sr4.GameRaceData.target_position)
  
  ::sr4::Vector3* temp = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
  return temp;
}
inline ::sr4::Vector3* GameRaceData::_internal_mutable_target_position() {
  
  if (_impl_.target_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::sr4::Vector3>(GetArenaForAllocation());
    _impl_.target_position_ = p;
  }
  return _impl_.target_position_;
}
inline ::sr4::Vector3* GameRaceData::mutable_target_position() {
  ::sr4::Vector3* _msg = _internal_mutable_target_position();
  // @@protoc_insertion_point(field_mutable:sr4.GameRaceData.target_position)
  return _msg;
}
inline void GameRaceData::set_allocated_target_position(::sr4::Vector3* target_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_position_;
  }
  if (target_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_position);
    if (message_arena != submessage_arena) {
      target_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_position_ = target_position;
  // @@protoc_insertion_point(field_set_allocated:sr4.GameRaceData.target_position)
}

// .sr4.Vector3 normal = 3;
inline bool GameRaceData::_internal_has_normal() const {
  return this != internal_default_instance() && _impl_.normal_ != nullptr;
}
inline bool GameRaceData::has_normal() const {
  return _internal_has_normal();
}
inline void GameRaceData::clear_normal() {
  if (GetArenaForAllocation() == nullptr && _impl_.normal_ != nullptr) {
    delete _impl_.normal_;
  }
  _impl_.normal_ = nullptr;
}
inline const ::sr4::Vector3& GameRaceData::_internal_normal() const {
  const ::sr4::Vector3* p = _impl_.normal_;
  return p != nullptr ? *p : reinterpret_cast<const ::sr4::Vector3&>(
      ::sr4::_Vector3_default_instance_);
}
inline const ::sr4::Vector3& GameRaceData::normal() const {
  // @@protoc_insertion_point(field_get:sr4.GameRaceData.normal)
  return _internal_normal();
}
inline void GameRaceData::unsafe_arena_set_allocated_normal(
    ::sr4::Vector3* normal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.normal_);
  }
  _impl_.normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sr4.GameRaceData.normal)
}
inline ::sr4::Vector3* GameRaceData::release_normal() {
  
  ::sr4::Vector3* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sr4::Vector3* GameRaceData::unsafe_arena_release_normal() {
  // @@protoc_insertion_point(field_release:sr4.GameRaceData.normal)
  
  ::sr4::Vector3* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
  return temp;
}
inline ::sr4::Vector3* GameRaceData::_internal_mutable_normal() {
  
  if (_impl_.normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::sr4::Vector3>(GetArenaForAllocation());
    _impl_.normal_ = p;
  }
  return _impl_.normal_;
}
inline ::sr4::Vector3* GameRaceData::mutable_normal() {
  ::sr4::Vector3* _msg = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:sr4.GameRaceData.normal)
  return _msg;
}
inline void GameRaceData::set_allocated_normal(::sr4::Vector3* normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.normal_;
  }
  if (normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(normal);
    if (message_arena != submessage_arena) {
      normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:sr4.GameRaceData.normal)
}

// -------------------------------------------------------------------

// GameFlowData

// .sr4.EGameFlowState current_flow_state = 1;
inline void GameFlowData::clear_current_flow_state() {
  _impl_.current_flow_state_ = 0;
}
inline ::sr4::EGameFlowState GameFlowData::_internal_current_flow_state() const {
  return static_cast< ::sr4::EGameFlowState >(_impl_.current_flow_state_);
}
inline ::sr4::EGameFlowState GameFlowData::current_flow_state() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.current_flow_state)
  return _internal_current_flow_state();
}
inline void GameFlowData::_internal_set_current_flow_state(::sr4::EGameFlowState value) {
  
  _impl_.current_flow_state_ = value;
}
inline void GameFlowData::set_current_flow_state(::sr4::EGameFlowState value) {
  _internal_set_current_flow_state(value);
  // @@protoc_insertion_point(field_set:sr4.GameFlowData.current_flow_state)
}

// .sr4.EGameMode selected_mode = 2;
inline void GameFlowData::clear_selected_mode() {
  _impl_.selected_mode_ = 0;
}
inline ::sr4::EGameMode GameFlowData::_internal_selected_mode() const {
  return static_cast< ::sr4::EGameMode >(_impl_.selected_mode_);
}
inline ::sr4::EGameMode GameFlowData::selected_mode() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.selected_mode)
  return _internal_selected_mode();
}
inline void GameFlowData::_internal_set_selected_mode(::sr4::EGameMode value) {
  
  _impl_.selected_mode_ = value;
}
inline void GameFlowData::set_selected_mode(::sr4::EGameMode value) {
  _internal_set_selected_mode(value);
  // @@protoc_insertion_point(field_set:sr4.GameFlowData.selected_mode)
}

// .sr4.ETrack selected_track = 3;
inline void GameFlowData::clear_selected_track() {
  _impl_.selected_track_ = 0;
}
inline ::sr4::ETrack GameFlowData::_internal_selected_track() const {
  return static_cast< ::sr4::ETrack >(_impl_.selected_track_);
}
inline ::sr4::ETrack GameFlowData::selected_track() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.selected_track)
  return _internal_selected_track();
}
inline void GameFlowData::_internal_set_selected_track(::sr4::ETrack value) {
  
  _impl_.selected_track_ = value;
}
inline void GameFlowData::set_selected_track(::sr4::ETrack value) {
  _internal_set_selected_track(value);
  // @@protoc_insertion_point(field_set:sr4.GameFlowData.selected_track)
}

// .sr4.ERouteDirection selected_route_direction = 4;
inline void GameFlowData::clear_selected_route_direction() {
  _impl_.selected_route_direction_ = 0;
}
inline ::sr4::ERouteDirection GameFlowData::_internal_selected_route_direction() const {
  return static_cast< ::sr4::ERouteDirection >(_impl_.selected_route_direction_);
}
inline ::sr4::ERouteDirection GameFlowData::selected_route_direction() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.selected_route_direction)
  return _internal_selected_route_direction();
}
inline void GameFlowData::_internal_set_selected_route_direction(::sr4::ERouteDirection value) {
  
  _impl_.selected_route_direction_ = value;
}
inline void GameFlowData::set_selected_route_direction(::sr4::ERouteDirection value) {
  _internal_set_selected_route_direction(value);
  // @@protoc_insertion_point(field_set:sr4.GameFlowData.selected_route_direction)
}

// .sr4.EVehicleType selected_vehicle = 5;
inline void GameFlowData::clear_selected_vehicle() {
  _impl_.selected_vehicle_ = 0;
}
inline ::sr4::EVehicleType GameFlowData::_internal_selected_vehicle() const {
  return static_cast< ::sr4::EVehicleType >(_impl_.selected_vehicle_);
}
inline ::sr4::EVehicleType GameFlowData::selected_vehicle() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.selected_vehicle)
  return _internal_selected_vehicle();
}
inline void GameFlowData::_internal_set_selected_vehicle(::sr4::EVehicleType value) {
  
  _impl_.selected_vehicle_ = value;
}
inline void GameFlowData::set_selected_vehicle(::sr4::EVehicleType value) {
  _internal_set_selected_vehicle(value);
  // @@protoc_insertion_point(field_set:sr4.GameFlowData.selected_vehicle)
}

// .sr4.EPhotoType selected_photo = 6;
inline void GameFlowData::clear_selected_photo() {
  _impl_.selected_photo_ = 0;
}
inline ::sr4::EPhotoType GameFlowData::_internal_selected_photo() const {
  return static_cast< ::sr4::EPhotoType >(_impl_.selected_photo_);
}
inline ::sr4::EPhotoType GameFlowData::selected_photo() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.selected_photo)
  return _internal_selected_photo();
}
inline void GameFlowData::_internal_set_selected_photo(::sr4::EPhotoType value) {
  
  _impl_.selected_photo_ = value;
}
inline void GameFlowData::set_selected_photo(::sr4::EPhotoType value) {
  _internal_set_selected_photo(value);
  // @@protoc_insertion_point(field_set:sr4.GameFlowData.selected_photo)
}

// .sr4.GameRaceData race_data = 7;
inline bool GameFlowData::_internal_has_race_data() const {
  return this != internal_default_instance() && _impl_.race_data_ != nullptr;
}
inline bool GameFlowData::has_race_data() const {
  return _internal_has_race_data();
}
inline void GameFlowData::clear_race_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.race_data_ != nullptr) {
    delete _impl_.race_data_;
  }
  _impl_.race_data_ = nullptr;
}
inline const ::sr4::GameRaceData& GameFlowData::_internal_race_data() const {
  const ::sr4::GameRaceData* p = _impl_.race_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sr4::GameRaceData&>(
      ::sr4::_GameRaceData_default_instance_);
}
inline const ::sr4::GameRaceData& GameFlowData::race_data() const {
  // @@protoc_insertion_point(field_get:sr4.GameFlowData.race_data)
  return _internal_race_data();
}
inline void GameFlowData::unsafe_arena_set_allocated_race_data(
    ::sr4::GameRaceData* race_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.race_data_);
  }
  _impl_.race_data_ = race_data;
  if (race_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sr4.GameFlowData.race_data)
}
inline ::sr4::GameRaceData* GameFlowData::release_race_data() {
  
  ::sr4::GameRaceData* temp = _impl_.race_data_;
  _impl_.race_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sr4::GameRaceData* GameFlowData::unsafe_arena_release_race_data() {
  // @@protoc_insertion_point(field_release:sr4.GameFlowData.race_data)
  
  ::sr4::GameRaceData* temp = _impl_.race_data_;
  _impl_.race_data_ = nullptr;
  return temp;
}
inline ::sr4::GameRaceData* GameFlowData::_internal_mutable_race_data() {
  
  if (_impl_.race_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sr4::GameRaceData>(GetArenaForAllocation());
    _impl_.race_data_ = p;
  }
  return _impl_.race_data_;
}
inline ::sr4::GameRaceData* GameFlowData::mutable_race_data() {
  ::sr4::GameRaceData* _msg = _internal_mutable_race_data();
  // @@protoc_insertion_point(field_mutable:sr4.GameFlowData.race_data)
  return _msg;
}
inline void GameFlowData::set_allocated_race_data(::sr4::GameRaceData* race_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.race_data_;
  }
  if (race_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(race_data);
    if (message_arena != submessage_arena) {
      race_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, race_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.race_data_ = race_data;
  // @@protoc_insertion_point(field_set_allocated:sr4.GameFlowData.race_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sr4

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sr4::EGameFlowState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sr4::EGameFlowState>() {
  return ::sr4::EGameFlowState_descriptor();
}
template <> struct is_proto_enum< ::sr4::EGameMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sr4::EGameMode>() {
  return ::sr4::EGameMode_descriptor();
}
template <> struct is_proto_enum< ::sr4::ETrack> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sr4::ETrack>() {
  return ::sr4::ETrack_descriptor();
}
template <> struct is_proto_enum< ::sr4::ERouteDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sr4::ERouteDirection>() {
  return ::sr4::ERouteDirection_descriptor();
}
template <> struct is_proto_enum< ::sr4::EVehicleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sr4::EVehicleType>() {
  return ::sr4::EVehicleType_descriptor();
}
template <> struct is_proto_enum< ::sr4::EPhotoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sr4::EPhotoType>() {
  return ::sr4::EPhotoType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GameFlowData_2eproto
